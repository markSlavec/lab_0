import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns



# 1. С помощью массивов numpy создайте таблицу умножения.
# Создаем массив чисел от 1 до 10
numbers = np.arange(1, 11)

# Умножаем массив на его транспонированный вариант, создавая таблицу умножения
multiplication_table = np.outer(numbers, numbers)

# Выводим таблицу умножения
print("Таблица умножения:\n", multiplication_table)


# 2. Создайте функцию, которая принимает как аргументы целое число N
# и первый элемент (вещественное число), и
# разность (вещественное число) и создает матрицу
# numpy по диагонали, которой располагаются первые N членов арифметической прогрессии.

def arithmetic_progression_matrix(N, first, diff):
    # Генерируем первые N членов арифметической прогрессии
    progression = np.arange(first, first + N * diff, diff)

    # Создаем диагональную матрицу с прогрессией на диагонали
    matrix = np.diag(progression)

    return matrix


# Пример вызова функции
print("Матрица с арифметической прогрессией по диагонали:\n", arithmetic_progression_matrix(5, 1.0, 2.0))


# 3. Сгенерируйте средствами numpy матрицу А 5 на 5, содержащую последовательные
# числа от 1 до 25. Используя срезы извлеките в плоский массив все нечетные элементы этой матрицы.


# Создаем матрицу 5x5 с последовательными числами от 1 до 25
matrix_A = np.arange(1, 26).reshape(5, 5)

# Извлекаем все нечетные элементы в плоский массив
odd_elements = matrix_A[matrix_A % 2 != 0]

print("Плоский массив с нечетными элементами:\n", odd_elements)


# 4. Создайте двумерный массив, содержащий единицы на границе и нули внутри.
# Создаем матрицу 7x7 с единицами
border_matrix = np.ones((7, 7))

# Устанавливаем внутренние элементы на 0
border_matrix[1:-1, 1:-1] = 0

print("Матрица с единицами на границе и нулями внутри:\n", border_matrix)



# 5. Создайте две матрицы размером (5,5). Одна матрица содержит 5 в шахматном порядке
# как в задаче домашнего задания, другая имеет треугольную форму содержащую
# 5 на основной диагонали и в позициях выше ее, а ниже все 0.
# Посчитайте их детерминант и найдите обратные матрицы.


# Матрица с шахматным порядком
chess_matrix = np.zeros((5, 5))
chess_matrix[::2, ::2] = 5
chess_matrix[1::2, 1::2] = 5

# Треугольная матрица
triangular_matrix = np.triu(np.full((5, 5), 5))

# Детерминанты
det_chess = np.linalg.det(chess_matrix)
det_triangular = np.linalg.det(triangular_matrix)

# Обратные матрицы
inv_chess = np.linalg.inv(chess_matrix) if det_chess != 0 else "Матрица необратима"
inv_triangular = np.linalg.inv(triangular_matrix) if det_triangular != 0 else "Матрица необратима"

print("Детерминант шахматной матрицы:", det_chess)
print("Обратная шахматная матрица:\n", inv_chess)
print("Детерминант треугольной матрицы:", det_triangular)
print("Обратная треугольная матрица:\n", inv_triangular)




# 6. С помощью pandas загрузите датасет для предсказания цены квартиры, прилагающийся к этой работе.

# Загрузка датасета
df = pd.read_csv("data.csv")
print("Датасет загружен")



# 7. Выведите на экран несколько первых и несколько последний строк файла.

# Показ первых 5 строк
print("Первые 5 строк:\n", df.head())

# Показ последних 5 строк
print("Последние 5 строк:\n", df.tail())



# 8. Выведите с помощью методов pandas основные количественные параметры датасета:
# количество строк и столбцов, тип данных каждого поля, количество значений
# в каждом столбце, шкала измерения каждого численного поля.

# Основные параметры датасета
print("Количество строк и столбцов:", df.shape)
print("Тип данных каждого столбца:\n", df.dtypes)
print("Количество значений в каждом столбце:\n", df.count())
print("Описание численных полей:\n", df.describe())


# 9. Удалите из таблицы столбцы, содержащие идентификаторы, переименуйте
# все оставшиеся названия колонок на русском языке.

# Удаляем идентификаторы
df = df.drop(columns=["Id", "DistrictId"], errors='ignore')

# Переименовываем оставшиеся столбцы на русском языке
df.columns = [
    "Комнаты", "Площадь", "Жилая площадь", "Площадь кухни", "Этаж", "Этажей в доме", "Год постройки",
    "Экология 1", "Экология 2", "Экология 3", "Социальное 1", "Социальное 2", "Социальное 3",
    "Медицина 1", "Медицина 2", "Магазины 1", "Магазины 2", "Цена"
]

# Проверяем результат
print("Таблица после удаления идентификаторов и переименования столбцов:\n", df.head())




# 10. Выведите отдельно столбец, содержащий цену, по номеру и названию.
# Выведите первую, десятую и предпоследнюю строку таблицы по номеру и по индексу.

# Столбец с ценой по названию и номеру
price_column_by_name = df["Цена"]
price_column_by_index = df.iloc[:, -1]  # Цена - последний столбец

# Вывод первой, десятой и предпоследней строки по номеру
first_row = df.iloc[0]
tenth_row = df.iloc[9]
penultimate_row = df.iloc[-2]

print("Столбец с ценой по названию:\n", price_column_by_name)
print("Столбец с ценой по индексу:\n", price_column_by_index)

print("Первая строка:\n", first_row)
print("Десятая строка:\n", tenth_row)
print("Предпоследняя строка:\n", penultimate_row)



# 11. Выделите в отдельную таблицу последние десять строк.
# Уберите в ней столбец с ценой. Склейте ее с первоначальной таблицей
# при помощи append. Заполните отсутствующие значения цены средним по таблице.

# Отдельная таблица из последних 10 строк без столбца "Цена"
last_10_rows = df.tail(10).drop(columns=["Цена"])

combined_df = pd.concat([df, last_10_rows], ignore_index=True)

# Заполняем отсутствующие значения в столбце "Цена" средним значением по таблице
average_price = df["Цена"].mean()
combined_df["Цена"] = combined_df["Цена"].fillna(average_price)

print("Таблица после добавления последних 10 строк и заполнения NaN средней ценой:\n", combined_df.tail(15))



# 12. Выделите пять последних колонок в отдельную таблицу. Удалите в ней строки,
# в которых цена ниже среднего. Присоедините эту таблицу к изначальной
# (выберите самый подходящий тип соединения).

# Создаем таблицу с пятью последними колонками
last_5_columns_df = df.iloc[:, -5:]

# Средняя цена
average_price = df["Цена"].mean()

# Удаляем строки, где "Цена" ниже среднего
filtered_last_5_columns_df = last_5_columns_df[last_5_columns_df["Цена"] >= average_price]

# Присоединяем полученную таблицу к исходной с помощью конкатенации
combined_df_12 = pd.concat([df, filtered_last_5_columns_df], axis=0, ignore_index=True)

print("Результирующая таблица после соединения:\n", combined_df_12.tail(15))




# 13.Выведите таблицу, содержащую среднюю цену и
# количество квартир на каждом этаже из первоначального набора данных.


# Группировка по этажам, вычисление средней цены и количества квартир
floor_stats = df.groupby("Этаж").agg(Средняя_цена=("Цена", "mean"), Количество_квартир=("Цена", "size"))

print("Таблица со средней ценой и количеством квартир на каждом этаже:\n", floor_stats)



# 14.Сохраните получившуюся таблицу в файлы формата csv и xlsx.
# Прочитайте их и убедитесь, что данные отображаются корректно.

floor_stats.to_csv("floor_stats.csv")
floor_stats.to_excel("floor_stats.xlsx")

# Чтение из файлов для проверки
csv_check = pd.read_csv("floor_stats.csv", index_col=0)
xlsx_check = pd.read_excel("floor_stats.xlsx", index_col=0)

print("Проверка данных из CSV:\n", csv_check.head())
print("Проверка данных из XLSX:\n", xlsx_check.head())


# 15. Создайте в Excel или другом табличном редакторе таблицу,
# содержащую несколько численных и текстовых полей. Прочитайте ее в программу при помощи pandas.

# Чтение данных из файла Excel
data = pd.read_excel("data_15.xlsx")
print(data)




# 16. Постройте круговую диаграмму для признака Rooms,
# иллюстрирующую количество квартир в процентах в зависимости от количества комнат.
# Сделайте сектор с наибольшим числом квартир выдвинутым.

# Подсчитываем количество квартир для каждого значения в "Комнаты"
rooms_counts = df["Комнаты"].value_counts()

# Построение круговой диаграммы
plt.figure(figsize=(8, 8))
plt.pie(rooms_counts, labels=rooms_counts.index, autopct='%1.1f%%', explode=[0.1 if i == rooms_counts.idxmax() else 0 for i in rooms_counts.index])
plt.title("Распределение квартир по количеству комнат")
plt.show()




# 17. Постройте гистограмму по целевой переменной Price.
# Оцените визуально, по какой цене продаётся наибольшее количество квартир.

# Построение гистограммы для цены
plt.figure(figsize=(10, 6))
plt.hist(df["Цена"], bins=30, edgecolor='black')
plt.title("Распределение цен на квартиры")
plt.xlabel("Цена")
plt.ylabel("Количество квартир")
plt.show()



# 18. Постройте диаграммы рассеяния для признаков Rooms,
# Square, HouseFloor, HouseYear в зависимости от целевой переменной
# Price в одной области figure. Оцените визуально, есть ли
# среди них такие, на которых разброс точек близок к линейной функции.

# Построение диаграмм рассеяния
plt.figure(figsize=(12, 10))

# Различные признаки в зависимости от "Цена"
for i, column in enumerate(["Комнаты", "Площадь", "Этажей в доме", "Год постройки"], 1):
    plt.subplot(2, 2, i)
    plt.scatter(df[column], df["Цена"], alpha=0.5)
    plt.xlabel(column)
    plt.ylabel("Цена")
    plt.title(f"{column} vs Цена")

plt.tight_layout()
plt.show()



# 19. Постройте ядерную оценку плотности целевой переменной Price.
# Оцените визуально, напоминает ли полученный график нормальное распределение.
# Постройте двумерную ядерную оценку плотности для целевой переменной Price и признака
# HouseFloor, затем оцените визуально на каких этажах и по какой цене продаётся основная масса квартир.


# Ядерная оценка плотности для "Цена"
plt.figure(figsize=(10, 6))
sns.kdeplot(df["Цена"], fill=True)
plt.title("Ядерная оценка плотности для цены")
plt.xlabel("Цена")
plt.ylabel("Плотность")
plt.show()

# Двумерная ядерная оценка плотности для "Цена" и "Этаж"
plt.figure(figsize=(10, 6))
sns.kdeplot(data=df, x="Этаж", y="Цена", fill=True)
plt.title("Двумерная ядерная оценка плотности для цены и этажа")
plt.xlabel("Этаж")
plt.ylabel("Цена")
plt.show()


# 20. Постройте ящиковую диаграмму признака Square. Оцените визуально имеются ли выбросы,
# и, если да, то начиная с какого размера площади значение признака можно считать выбросом.


# Ящиковая диаграмма для площади
plt.figure(figsize=(8, 6))
sns.boxplot(x=df["Площадь"])
plt.title("Ящиковая диаграмма для площади квартир")
plt.xlabel("Площадь")
plt.show()



# !!!!! Добавить другое решение без урезание данных
# 21. При помощи сетки графиков PairGrid визуализируйте попарные отношения
# признаков Rooms, Square, HouseFloor, HouseYear, Price следующим
# образом: на диагонали - гистограммы, под диагональю - ядерные оценки
# плотности, над диагональю - диаграммы рассеяния. По результатам визуализации сделайте выводы.


# Выбираем нужные столбцы и сокращаем размер данных
subset_df = df[["Комнаты", "Площадь", "Этажей в доме", "Год постройки", "Цена"]].head(1000)

# Создаем PairGrid для визуализации с сокращенным набором данных
g = sns.PairGrid(subset_df)
g.map_diag(sns.histplot, kde=True)                 # Гистограммы с оценкой плотности на диагонали
g.map_lower(sns.kdeplot, fill=True, cmap="Blues")   # Ядерные оценки плотности под диагональю
g.map_upper(sns.scatterplot, alpha=0.6, color="blue")  # Диаграммы рассеяния над диагональю

# Добавляем заголовок
plt.subplots_adjust(top=0.95)
g.fig.suptitle("Взаимосвязь признаков (подмножество данных)")






# 22 Постройте тепловую карту матрицы корреляции (df.corr())
# признаков Rooms, Square, HouseFloor, HouseYear, Price.
# По ней определите, какие признаки являются зависимыми
# (у таких признаков коэффициент корреляции близок к единице).

# Выбираем интересующие признаки и считаем корреляцию
correlation_matrix = df[["Комнаты", "Площадь", "Этажей в доме", "Год постройки", "Цена"]].corr()

# Строим тепловую карту матрицы корреляций
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", vmin=-1, vmax=1, fmt=".2f", linewidths=0.5)

# Добавляем заголовок и отступы
plt.title("Тепловая карта корреляций между признаками")
plt.show()


# 23. Выведите на экран текстовый вывод, определяющий зависимые
# признаки на основе тепловой карты корреляций из предыдущего задания.

# Определение зависимых признаков
strong_correlation = correlation_matrix[(correlation_matrix > 0.8) & (correlation_matrix < 1.0)]

# Печать зависимых признаков с высокими коэффициентами корреляции
for row in strong_correlation.columns:
    high_corr_features = strong_correlation.index[strong_correlation[row].notna()].tolist()
    if high_corr_features:
        print(f"Признак '{row}' имеет высокую корреляцию с: {', '.join(high_corr_features)}")












